(self.webpackChunkdynamo_docs=self.webpackChunkdynamo_docs||[]).push([[606],{1504:(e,t,r)=>{"use strict";r.d(t,{Z:()=>a});var n=r(7294),o=r(9942);o.Z.initialize({startOnLoad:!0});const a=e=>{let{chart:t}=e;return(0,n.useEffect)((()=>{o.Z.contentLoaded()}),[]),n.createElement("div",{className:"mermaid"},t)}},9173:(e,t,r)=>{"use strict";r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>g,frontMatter:()=>s,metadata:()=>d,toc:()=>u});var n=r(7462),o=(r(7294),r(3905)),a=r(1504);const s={sidebar_position:2,title:"Governance"},i=void 0,d={unversionedId:"Dynamo/Vaults/governance",id:"Dynamo/Vaults/governance",title:"Governance",description:"Dynamo crowd sources optimal wealth allocations across various liquidity/lending platforms.",source:"@site/docs/Dynamo/Vaults/governance.mdx",sourceDirName:"Dynamo/Vaults",slug:"/Dynamo/Vaults/governance",permalink:"/docs/Dynamo/Vaults/governance",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Dynamo/Vaults/governance.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"Governance"},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/docs/Dynamo/Vaults/intro"},next:{title:"Stablecoin liquidity",permalink:"/docs/General/liquidity"}},l={},u=[{value:"Proposing a Strategy",id:"proposing-a-strategy",level:3},{value:"submitStrategy",id:"submitstrategy",level:4},{value:"Withdrawing a Strategy",id:"withdrawing-a-strategy",level:3},{value:"withdrawStrategy",id:"withdrawstrategy",level:4},{value:"Evaluating and Interceding on a Proposed Strategy",id:"evaluating-and-interceding-on-a-proposed-strategy",level:3},{value:"rejectStartegy",id:"rejectstartegy",level:4},{value:"endorseStartegy",id:"endorsestartegy",level:4},{value:"Activating a Proposed Strategy",id:"activating-a-proposed-strategy",level:3},{value:"activateStrategy",id:"activatestrategy",level:4},{value:"Governance of Governance",id:"governance-of-governance",level:3},{value:"addGuard",id:"addguard",level:4},{value:"removeGuard",id:"removeguard",level:4},{value:"swapGuard",id:"swapguard",level:4},{value:"replaceGovernance",id:"replacegovernance",level:4}],c={toc:u};function g(e){let{components:t,...r}=e;return(0,o.kt)("wrapper",(0,n.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Dynamo crowd sources optimal wealth allocations across various liquidity/lending platforms.\nSuch an allocation, proposed or active, is called a Strategy.\nThe expectation that just about anyone is allowed to propose a Strategy introduces a likely significantly higher rate of submissions across the Ethereum ecosystem.\nThe typical voting method of deciding which decision to make is both unweildy and would require far too much active participation by others who have investments in our protocol.\nOn the other hand, if the protocol has no restrictions on who and when Strategies can be proposed nor a process in which to edjudicate their acceptance, bad actors could use this openess as a vector to attempt denial of service attacks that would break down then entire value of the protocol."),(0,o.kt)("p",null,'Dynamo has adopted a Governance policy that is optimistic in assuming most submitted Strategies are valid so, unless someone involved in Governance makes the effort to reject a Strategy, it will ultimately be accepted and activated in a reasonable period of time.\nTo protect against bad actors, however, there is a "decision period" that starts when a new Strategy is proposed in which a select group of Governance Guards may choose to block an invalid Strategy. Optionally, the Guards may even short circuit the waiting time by having an absolute majority vote to endorse the Strategy so it may be activated right away.'),(0,o.kt)("p",null,"This DAO-like governance model assumes Strategies proposed are valid and should be accepted by default.\nGuards need only intervene if a proposed Strategy appears to be something other than it claims to be or if there is an exceptional situation where either market forces or ecosystem issues introduce an urgency for the existing active Strategy to be replaced as quickly as possible."),(0,o.kt)("h3",{id:"proposing-a-strategy"},"Proposing a Strategy"),(0,o.kt)("p",null,"To propose a new Strategy, four conditions must be met:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"The Proposer must meet the qualifications to make a proposal. (P",(0,o.kt)("sub",null,"E")," - see below.)"),(0,o.kt)("li",{parentName:"ol"},"The Proposer must not be subject to some explicit prohibition from submitting strategies. (P",(0,o.kt)("sub",null,"X")," - see below.)"),(0,o.kt)("li",{parentName:"ol"},'There must not be a proposed Strategy that is still pending during the "decision period" or "activation period".'),(0,o.kt)("li",{parentName:"ol"},"The proposed Strategy must meet certain criteria in terms of minimum margin of improvement requirements.")),(0,o.kt)("p",null,"A proposed Strategy contains both the wealth allocation recommendations as well as the claims for what the current Strategy's yield, APY",(0,o.kt)("sub",null,"CURRENT"),", is and what the proposed Strategy's yield, APY",(0,o.kt)("sub",null,"PROPOSED"),", would be. The Governance DAO contract will confirm the first three conditions authoritatively. So long as APY",(0,o.kt)("sub",null,"PROPOSED")," - APY",(0,o.kt)("sub",null,"CURRENT")," > the minimum improvement, APY",(0,o.kt)("sub",null,"DELTA"),", then condition #4 is assumed to be met by the Governance DAO contract but it assumes that external Guards will check that the claims are within spec and take action to prevent its activation if not."),(0,o.kt)("p",null,'The "decision period" now starts and no other Strategy can be proposed until this one is properly adjudicated.'),(0,o.kt)("h4",{id:"submitstrategy"},"submitStrategy"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Given:")),(0,o.kt)("p",null,"P",(0,o.kt)("sub",null,"E")," = Predicate - Proposer must meet certain qualification for eligibility. (Must resolve to True)"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Ex: hold a certain quantity of vault tokens. TBD")),(0,o.kt)("p",null,"P",(0,o.kt)("sub",null,"X")," = Predicate - Proposer must not be subject to some form of exclusion. (Must resolve to False)"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Ex: having been rejected in last 24 hrs or on a black list. TBD")),(0,o.kt)("p",null,"T",(0,o.kt)("sub",null,"DELAY")," = Variable - How long after a strategy is submitted until it can be activated so long as it is not rejected/overwhelmingly endorsed."),(0,o.kt)("p",null,"MAX_GUARDS = Constant - Maximum number of Guards who may vote on Proposed Strategies."),(0,o.kt)("p",null,"L",(0,o.kt)("sub",null,"GOV"),"[MAX_GUARDS]"," = Variable - List of addresses of Governance Guards who vote on Strategy Submissions."),(0,o.kt)("p",null,"Strategy = (Proposed) Struct = { Nonce, Proposer Addr, Weights[], T",(0,o.kt)("sub",null,"SUBMITTED"),", T",(0,o.kt)("sub",null,"ACTIVATED"),", Withdrawn, len(L",(0,o.kt)("sub",null,"GOV"),"), Votes",(0,o.kt)("sub",null,"ENDORSE"),", Votes",(0,o.kt)("sub",null,"REJECT")," }"),(0,o.kt)(a.Z,{chart:"\nsequenceDiagram\n    participant P as Proposer\n    participant C1 as Governance Contract\n    participant N as Ethereum Network\n    autonumber\n    Note over P: Pre-Conditions:<br>Addr=User.wallet<br>Weights=[list of lending platform weights]<br>APYNow=(user calculation)<br>APYPredicted=(user calculation)<br>Strategy = {Nonce=0, Addr, Weights, APYNow, APYPredicted}\n    Note over C1: Pre-Conditions:<br>self.CurrentStrategy = (Current Active Strategy)<br> self.PendingStrategy = (Current Pending Strategy) <br> self.PendingStrategy= (self.CurrentStrategy || some other)<br>self.NextNonce=(next StrategyID > 0)<br>self.TDelay=(wait time for proposed Strategy)<br>self.MinimumAPYIncrease=(min improvement to consider Strategy)<br>self.LGOV = list of Governance Voter addresses\n    P->>C1:submitStrategy(Strategy)\n    Note over C1: No Strategy proposals if no governance guards <br> len(self.LGOV) > 0\n    Note over C1: Confirm No Currently Pending Strategy<br>(likely incomplete TBD)<br>self.CurrentStrategy==self.PendingStrategy ||<br>self.PendingStrategy.Withdrawn==True ||<br>count(self.PendingVotesReject)>len(self.LGOV)/2 ||<br>(self.PendingStrategy.TSubmitted+(self.TDelay * 1.25) < now() and<br>count(self.PendingStrategy.VotesReject)>count(self.PendingStrategy.VotesEndorsed)\n    C1 ->> C1: _noPendingStrategy() == True\n    Note over C1: Confirm msg.sender Eligibility<br>(TBD)\n    C1->>C1:PE() == True\n    Note over C1: Confirm msg.sender is not blacklisted<br>(TBD)\n    C1->>C1:PX() == FALSE\n    Note over C1: Confirm Strategy.APYPredicted - Strategy.APYNow >= self.MinimumAPYIncrease\n    Note over C1: Construct the New Strategy<br>TSubmitted=now()<br>TActive=0<br>Nonce=self.NextNonce<br>self.NextNonce+=1<br>VoterCount=len(self.LGOV)<br>Strategy={*Strategy,TSubmitted,TActive,Nonce,Withdrawn=False,VoterCount,VotesEndorse=[],VotesReject=[]}\n    Note Over C1: self.PendingStrategy = Strategy\n    C1--\x3e>N: Emit Event StrategyProposal(Strategy)\n    C1->>P: return self.PendingStrategy.Nonce",mdxType:"Mermaid"}),(0,o.kt)("h3",{id:"withdrawing-a-strategy"},"Withdrawing a Strategy"),(0,o.kt)("p",null,"If there is a Pending Strategy, the ",(0,o.kt)("strong",{parentName:"p"},"original proposer")," may elect to withdraw it at any time so that a new Strategy proposal can replace it."),(0,o.kt)("h4",{id:"withdrawstrategy"},"withdrawStrategy"),(0,o.kt)(a.Z,{chart:"\nsequenceDiagram\n    participant P as Proposer\n    participant C1 as Governance Contract\n    participant N as Ethereum Network\n    autonumber\n    Note over P:<br> Pre-Conditions:<br> Nonce = (Nonce of previously submitted strategy)\n    Note over C1: Pre-Conditions:<br>self.CurrentStrategy = (Current active Strategy)<br> self.PendingStrategy = (Current Pending Strategy)\n    P->>C1: withdrawStrategy(Nonce)\n    Note over C1: Confirm there is a Currently Pending Strategy<br>(likely incomplete TBD)<br>self.CurrentStrategy != self.PendingStrategy \n    C1 ->> C1: _noPendingStrategy() == False\n    Note over C1: Confirm Pending Strategy is the Strategy we want to withdraw <br> self.PendingStrategy.Nonce == Nonce\n    Note over C1: Confirm Sender is the Strategy Proposer \n    Note over C1: Confirm msg.sender == self.PendingStrategy.ProposerAddress\n    Note over C1:Set self.PendingStrategy.Withdrawn = True\n    C1--\x3e>N: Emit Event StrategyWithdrawal(Nonce)\n    C1--\x3e>P: return True",mdxType:"Mermaid"}),(0,o.kt)("h3",{id:"evaluating-and-interceding-on-a-proposed-strategy"},"Evaluating and Interceding on a Proposed Strategy"),(0,o.kt)("p",null,"Dynamo will operate bots that watch for StrategyProposal events and then also perform the calculations for determining the APY",(0,o.kt)("sub",null,"PROPOSED")," - APY",(0,o.kt)("sub",null,"CURRENT")," values for current and proposed Strategies. If the values resulting from the proposed Strategy's inputs coincide with the claimed values in the proposed Strategy as submitted then the bots can do nothing. If the values are significantly out of bounds then the bots will alert that the proposed Strategy is likely invalid so that Guards can decide to re-evaluate the proposed Strategy and reject the proposal if desired."),(0,o.kt)("p",null,"A single rejection is enough to block a Proposed Strategy from being active if no other votes are made regarding the Proposed Strategy. If there is any rejection vote, the only way a Proposed Strategy can be enabled is for there to be a majority of Endorsement votes. Tied votes still result in a rejection."),(0,o.kt)("p",null,'An absolute majority vote can enable the Proposed Strategy to short circuit the "decision period" time. At the time a Proposed Strategy is submitted, the number of Guards eligible to vote is tracked by the Proposed Strategy so that the potential vote count is known. Guards may be added or removed from the Governance Contract but the vote count that matters is based on the potential votes at the time the Proposed Strategy is submitted. If more than half the total potential votes are cast for rejection then a new Proposed Strategy may be submitted without waiting for the "decision period" to expire. If more than half the total potential votes are cast for endorsement then the current Proposed Strategy may be activated right away.'),(0,o.kt)("p",null,'Guards may only vote once on a Proposed Strategy during the "activation period" and may not change their votes.'),(0,o.kt)("p",null,"TODO?: In order to provide an absolute protection against on-going DOS race condition attacks by bad actors constantly proposing new Strategies, we could add an optional Strategy parameter to the ",(0,o.kt)("inlineCode",{parentName:"p"},"rejectStrategy")," method which, if this reject vote results in an absolute rejection count, would immediately short circuit the waiting period and submit the new Strategy as a new Proposed Strategy. This may not be necessary if the predicates P",(0,o.kt)("sub",null,"E")," and P",(0,o.kt)("sub",null,"X")," are strong enough controls. It may also be the case, in the future, that Dynamo may want a more strict separation of concerns and disallow Governance Guards to submit Strategies or vote on Strategies they've submitted - but this may not be practical in a true decentralized environment."),(0,o.kt)("h4",{id:"rejectstartegy"},"rejectStartegy"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Given:")),(0,o.kt)("p",null,"T",(0,o.kt)("sub",null,"DELAY")," = Variable - How long after a strategy is submitted until it can be activated so long as it is not rejected/overwhelmingly endorsed."),(0,o.kt)("p",null,"MAX_GUARDS = Constant - Maximum number of Guards who may vote on Proposed Strategies."),(0,o.kt)("p",null,"L",(0,o.kt)("sub",null,"GOV"),"[MAX_GUARDS]"," = Variable - List of addresses of Governance Guards who vote on Strategy Submissions."),(0,o.kt)("p",null,"Strategy = (Proposed) Struct = { Nonce, Proposer Addr, Weights[], T",(0,o.kt)("sub",null,"SUBMITTED"),", T",(0,o.kt)("sub",null,"ACTIVATED"),", Withdrawn, len(L",(0,o.kt)("sub",null,"GOV"),"), Votes",(0,o.kt)("sub",null,"ENDORSE"),", Votes",(0,o.kt)("sub",null,"REJECT")," }"),(0,o.kt)(a.Z,{chart:"\nsequenceDiagram\n    participant G as Guard\n    participant C1 as Governance Contract\n    participant N as Ethereum Network\n    autonumber\n    Note over G:<br> Pre-Conditions:<br>Nonce = (Nonce of previously submitted <br> StrategyProposalEvent that the guard wishes to reject)\n    Note over C1: Pre-Conditions:<br>self.CurrentStrategy = (Current active strategy)<br> self.LGOV = list of Guards <br> self.PendingStrategy = (Current Pending Strategy)\n    G->>C1: rejectStrategy(Nonce)\n    Note over C1: Confirm there is a Currently Pending Strategy <br> self.CurrentStrategy != self.PendingStrategy\n    C1 ->> C1: _noPendingStrategy() == False\n    Note over C1: Confirm Pending Strategy is the Strategy we want to Reject<br> self.PendingStrategy.Nonce == Nonce\n    Note over C1: Confirm the Sender is a Guard Address in List of Guards\n    Note over C1: msg.sender is in self.LGOV\n    Note over C1: Confirm Sender has not yet voted \n    Note over C1: msg.sender is not in self.PendingStrategy.VoteReject and <br> msg.sender is not in self.PendingStrategy.VoteEndorse\n    Note over C1:self.PendingStrategy.VoteReject.Append(msg.sender)\n    C1--\x3e>N: Emit Event StrategyVote(Nonce, GuardAddress, Endorse=False)\n    C1--\x3e>G: return True\n",mdxType:"Mermaid"}),(0,o.kt)("h4",{id:"endorsestartegy"},"endorseStartegy"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Given:")),(0,o.kt)("p",null,"T",(0,o.kt)("sub",null,"DELAY")," = Variable - How long after a strategy is submitted until it can be activated so long as it is not rejected/overwhelmingly endorsed."),(0,o.kt)("p",null,"MAX_GUARDS = Constant - Maximum number of Guards who may vote on Proposed Strategies."),(0,o.kt)("p",null,"L",(0,o.kt)("sub",null,"GOV"),"[MAX_GUARDS]"," = Variable - List of addresses of Governance Guards who vote on Strategy Submissions."),(0,o.kt)("p",null,"Strategy = (Proposed) Struct = { Nonce, Proposer Addr, Weights[], T",(0,o.kt)("sub",null,"SUBMITTED"),", T",(0,o.kt)("sub",null,"ACTIVATED"),", Withdrawn, len(L",(0,o.kt)("sub",null,"GOV"),"), Votes",(0,o.kt)("sub",null,"ENDORSE"),", Votes",(0,o.kt)("sub",null,"REJECT")," }"),(0,o.kt)(a.Z,{chart:"\nsequenceDiagram\n    participant G as Guard\n    participant C1 as Governance Contract\n    participant N as Ethereum Network\n    autonumber\n    Note over G:<br> Pre-Conditions:<br>Nonce = (Nonce of previously submitted <br> StrategyProposalEvent that the guard wishes to endorse)\n    Note over C1: Pre-Conditions:<br>self.CurrentStrategy = (Current active strategy)<br> self.LGOV = list of Guards <br> self.PendingStrategy = (Current Pending Strategy)\n    G->>C1: endorseStrategy(Nonce)\n    Note over C1: Confirm there is a Currently Pending Strategy  <br> self.CurrentStrategy != self.PendingStrategy \n    C1 ->> C1: _noPendingStrategy() == False\n    Note over C1: Confirm Pending Strategy is the Strategy we want to Endorse <br> self.PendingStrategy.Nonce == Nonce\n    Note over C1: Confirm the Sender is a Guard Address in List of Guards\n    Note over C1: msg.sender is in self.LGOV\n    Note over C1: Confirm Sender has not yet voted \n    Note over C1: msg.sender is not in self.PendingStrategy.VoteReject and <br> msg.sender is not in self.PendingStrategy.VoteEndorse\n    Note over C1:self.PendingStrategy.VoteEndorse.Append(msg.sender)\n    C1--\x3e>N: Emit Event StrategyVote(Nonce, GuardAddress, Endorse=True)\n    C1--\x3e>G: return True\n",mdxType:"Mermaid"}),(0,o.kt)("h3",{id:"activating-a-proposed-strategy"},"Activating a Proposed Strategy"),(0,o.kt)("p",null,'Assuming either no reject votes have occurred or a majority of votes for endorsement have been registered and either the "decision period" has passed or been short circuited, a new "activation period" starts which gives time for someone to make an activateStrategy call against the Governance Contract to make the Proposed Strategy the new Active Strategy. That time period is set to 25% of the "decision period" time. During this time no other Proposed Strategy can be submitted so long as the pending Proposed Strategy remains inactive. Note that ANYONE can call the ',(0,o.kt)("inlineCode",{parentName:"p"},"activateStrategy")," function which credits the original proposer in terms of rewards but the actor making the function call pays the gas price for the function call and necessary rebalancing of the funds which could be expensive."),(0,o.kt)("p",null,"Note that there is no expiration time for calling ",(0,o.kt)("inlineCode",{parentName:"p"},"activateStrategy"),' so long as the Proposed Strategy is still eligible. It does not matter if the "activation period" has passed. Until such time that a new Proposed Strategy is in place, the present one may be activated at will.'),(0,o.kt)("h4",{id:"activatestrategy"},"activateStrategy"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Given:")),(0,o.kt)("p",null,"T",(0,o.kt)("sub",null,"DELAY")," = Variable - How long after a strategy is submitted until it can be activated so long as it is not rejected/overwhelmingly endorsed."),(0,o.kt)("p",null,"MAX_GUARDS = Constant - Maximum number of Guards who may vote on Proposed Strategies."),(0,o.kt)("p",null,"L",(0,o.kt)("sub",null,"GOV"),"[MAX_GUARDS]"," = Variable - List of addresses of Governance Guards who vote on Strategy Submissions."),(0,o.kt)("p",null,"Strategy = (Proposed) Struct = { Nonce, Proposer Addr, Weights[], T",(0,o.kt)("sub",null,"SUBMITTED"),", T",(0,o.kt)("sub",null,"ACTIVATED"),", Withdrawn, len(L",(0,o.kt)("sub",null,"GOV"),"), Votes",(0,o.kt)("sub",null,"ENDORSE"),", Votes",(0,o.kt)("sub",null,"REJECT")," }"),(0,o.kt)(a.Z,{chart:"\nsequenceDiagram\n    participant A as Any Role\n    participant C1 as Governance Contract\n    participant D as Dynamo Vault\n    participant N as Ethereum Network\n    autonumber\n    Note over A:<br> Pre-Conditions:<br>Nonce = (Nonce of previously submitted <br> StrategyProposalEvent that the guard wishes to endorse)\n    Note over C1: Pre-Conditions:<br>self.CurrentStrategy = (Current active Strategy)<br> self.TDelay=(wait time for proposed Strategy <br> self.PendingStrategy = (Current Pending Strategy)\n    A->>C1: activateStrategy(Nonce)\n    Note over C1: Confirm there is a Currently Pending Strategy <br>self.CurrentStrategy != self.PendingStrategy ||<br>self.PendingStrategy.Withdrawn==False \n    C1 ->> C1: _noPendingStrategy() == False\n    Note over C1: Confirm Pending Strategy is Approved by Guards <br>count(self.PendingVotesEndorse)>len(self.LGOV)/2 ||<br>(self.PendingStrategy.TSubmitted+self.TDelay < now() and<br>count(self.PendingStrategy.VotesReject)<count(self.PendingStrategy.VotesEndorsed)\n    Note over C1: Confirm Pending Strategy is the Strategy we want to Activate<br> self.PendingStrategy.Nonce == Nonce\n    Note over C1:self.PendingStrategy = self.CurrentStrategy\n    C1->>D: PoolRebalancer(self.CurrentStrategy)\n    C1--\x3e>N: Emit Event StrategyActivation(self.CurrentStrategy)\n    C1--\x3e>A: return True\n",mdxType:"Mermaid"}),(0,o.kt)("h3",{id:"governance-of-governance"},"Governance of Governance"),(0,o.kt)("p",null,"The Governance Contract Owner may add or remove Guards at will up to the limit of MAX_GUARDS.\nThe Governance Contract may be replaced with another one if 100% of all Guards vote to change to the same new Governance Contract."),(0,o.kt)("h4",{id:"addguard"},"addGuard"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Given:")),(0,o.kt)("p",null,"Owner = Variable - Address of Governance Contract Owner"),(0,o.kt)("p",null,"MAX_GUARDS = Constant - Maximum number of Guards who may vote on Proposed Strategies."),(0,o.kt)("p",null,"L",(0,o.kt)("sub",null,"GOV"),"[MAX_GUARDS]"," = Variable - List of addresses of Governance Guards who vote on Strategy Submissions."),(0,o.kt)(a.Z,{chart:"\nsequenceDiagram\n    participant OG as Owner\n    participant C1 as Governance Contract\n    participant N as Ethereum Network\n    autonumber\n    Note over C1: Pre-Conditions: <br> self.LGOV is the List of Current Guards <br> self.Owner is Governance Contract Owner Address <br> MAX_GUARDS is maximum count of guards\n    OG->>C1: addGuard(GuardAddress)\n    Note over C1: Confirm Sender is the Governance Contract Owner\n    Note over C1: msg.sender == self.Owner\n    Note over C1: Confirm the Guard being added is not in List of Guards\n    Note over C1: GuardAddress is not in self.LGOV\n    Note over C1: Confirm there is not the maximum amount of guards in the guard list\n    Note over C1: len(self.LGOV) is less than MAX_GUARDS\n    Note over C1: Confirm the Guard is a real address\n    Note over C1: GuardAddress != ZERO_ADDRESS\n    Note over C1: self.LGOV.Append(GuardAddress)\n    C1--\x3e>N: Emit Event NewGuard(GuardAddress)\n    C1--\x3e>OG: return True\n",mdxType:"Mermaid"}),(0,o.kt)("h4",{id:"removeguard"},"removeGuard"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Given:")),(0,o.kt)("p",null,"Owner = Variable - Address of Governance Contract Owner"),(0,o.kt)("p",null,"MAX_GUARDS = Constant - Maximum number of Guards who may vote on Proposed Strategies."),(0,o.kt)("p",null,"L",(0,o.kt)("sub",null,"GOV"),"[MAX_GUARDS]"," = Variable - List of addresses of Governance Guards who vote on Strategy Submissions."),(0,o.kt)("p",null,"Votes = map of Guard addr -> Contract Addr for votes on Governance Contract for Vault"),(0,o.kt)(a.Z,{chart:"\nsequenceDiagram\n    participant OG as Owner\n    participant C1 as Governance Contract\n    participant N as Ethereum Network\n    autonumber\n    Note over C1: Pre-Conditions: <br> self.LGOV is the List of Current Guards <br> self.Owner is Governance Contract Owner Address <br>self.Votes = (map of Guards -> Addr)\n    OG->>C1: removeGuard(GuardAddress)\n    Note over C1: Confirm Sender is the Governance Contract Owner\n    Note over C1: msg.sender == self.Owner\n    Note over C1: Confirm the Guard being removed is in List of Guards\n    Note over C1: GuardAddress is in self.LGOV\n    Note over C1: Erase old Guard's vote<br>self.Votes[GuardAddress] = ZERO_ADDRESS    \n    Note over C1: Replace Deleted Guard with Last Guard in List: <br> Index = position of GuardAddress in self.LGOV <br> Last_Pos = len(self.LGOV)<br> self.LGOV[Index] = self.LGOV[Last_Pos] <br> self.LGOV[Last_Pos] = ZERO_ADDRESS\n    C1--\x3e>N: Emit Event GuardRemoved(GuardAddress)\n    C1--\x3e>OG: return True\n",mdxType:"Mermaid"}),(0,o.kt)("h4",{id:"swapguard"},"swapGuard"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Given:")),(0,o.kt)("p",null,"Owner = Variable - Address of Governance Contract Owner"),(0,o.kt)("p",null,"MAX_GUARDS = Constant - Maximum number of Guards who may vote on Proposed Strategies."),(0,o.kt)("p",null,"L",(0,o.kt)("sub",null,"GOV"),"[MAX_GUARDS]"," = Variable - List of addresses of Governance Guards who vote on Strategy Submissions."),(0,o.kt)("p",null,"Votes = map of Guard addr -> Contract Addr for votes on Governance Contract for Vault"),(0,o.kt)(a.Z,{chart:"\nsequenceDiagram\n    participant OG as Owner\n    participant C1 as Governance Contract\n    participant N as Ethereum Network\n    autonumber\n    Note over C1: Pre-Conditions: <br> self.LGOV is the List of Current Guards <br> self.Owner is Governance Contract Owner Address <br>self.Votes = (map of Guards -> Addr)\n    OG->>C1: swapGuard(OldGuardAddress, NewGuardAddress)\n    Note over C1: Confirm Sender is the Governance Contract Owner\n    Note over C1: msg.sender == self.Owner \n    Note over C1: Confirm the New Guard being added is not in List of Guards<br>Note over C1: NewGuardAddress not in self.LGOV\n    Note over C1: Confirm the Old Guard being removed is in List of Guards<br>OldGuardAddress in self.LGOV\n    Note over C1: Confirm the New Guard is a real address<br>NewGuardAddress != ZERO_ADDRESS\n    Note over C1: Erase old Guard's vote<br>self.Votes[OldGuardAddress] = ZERO_ADDRESS\n    Note over C1: Replace Old Guard with New Guard: <br> Index = position of OldGuardAddress in self.LGOV <br>  self.LGOV[Index] = NewGuardAddress\n    C1--\x3e>N: Emit Event GuardSwap(OldGuardAddress, NewGuardAddress)\n    C1--\x3e>OG: return True\n",mdxType:"Mermaid"}),(0,o.kt)("h4",{id:"replacegovernance"},"replaceGovernance"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Given:")),(0,o.kt)("p",null,"MAX_GUARDS = Constant - Maximum number of Guards who may vote on Proposed Strategies.\nMIN_GUARDS = Contact - Minimum number of Guards which must exist for a Governance Contract change to even occur."),(0,o.kt)("p",null,"L",(0,o.kt)("sub",null,"GOV"),"[MAX_GUARDS]"," = Variable - List of addresses of Governance Guards who vote on Strategy Submissions."),(0,o.kt)("p",null,"Vault = address of Vault Contract which this contract provides governance over."),(0,o.kt)("p",null,"Votes = map of Guard addr -> Contract Addr for votes on Governance Contract for Vault"),(0,o.kt)(a.Z,{chart:"\nsequenceDiagram\n    participant G as Governor\n    participant C1 as Governance Contract\n    participant V as Vault Contract\n    participant N as Ethereum Network\n    autonumber\n    Note over G: NewGovernance = (address of new<br>Governance Contract)\n    Note over V: Pre-Conditions:<br>GovernanceAddr = (addr of Governance Contract)    \n    Note over C1: Pre-Conditions: <br>self.LGOV = (List of Current Guards)<br>MIN_GUARDS = (minimum number<br>of guards to change Governance)<br>self.Vault = (address of Vault Contract)<br>self.Votes = (map of Guards -> Addr)\n    G->>C1: replaceGovernance(NewGovernance)\n    Note over C1: Confirm there are enough Guards<br>to change Governance<br>len(self.LGOV >= MIN_GUARDS)\n    Note over C1: Confirm self.sender is a Guard<br>msg.sender in self.LGOV\n    Note over C1: Confirm NewGovernance is Different<br>NewConvernance != self<br>NewGovernance != ZERO_ADDRESS<br>self.Votes[msg.sender] != NewGovernance\n    Note over C1: Record Guard's Vote<br>self.Votes[msg.sender] = NewGovernance\n    Note over C1: See if we are unanimous<br>VoteCount = 0\n    loop for each Governor in self.LGOV\n        Note over C1: if self.Votes[Goveror] == NewGovernance: VoteCount += 1\n    end\n    C1--\x3e>N: emit NewGovernanceVote(self.Vault, msg.Sender, NewGovernance, VoteCount, len(self.LGOV))\n    alt if VoteCount == len(self.LGOV)\n        C1->>V: replaceGovernance(NewGovernance)\n    end\n    Note over V: Confirm request is from current<br>Govenance Contract<br>confirm msg.sender = self.GovernanceAddr\n    Note over V: Confirm NewGovernance is different<br>confirm NewGovernance != self.GovernanceAddr<br>confirm NewGovernance != ZERO_ADDRESS\n        V--\x3e>N: emit NewGovernanceContract(msg.Sender, self.GovernanceAddr, NewGovernance)\n    Note over V: Update Governance Contract<br>self.GovernanceAddr = NewGovernance\n",mdxType:"Mermaid"}))}g.isMDXComponent=!0},1748:(e,t,r)=>{var n={"./locale":9234,"./locale.js":9234};function o(e){var t=a(e);return r(t)}function a(e){if(!r.o(n,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return n[e]}o.keys=function(){return Object.keys(n)},o.resolve=a,e.exports=o,o.id=1748}}]);